import React, { useEffect, useRef, useState } from "react";
import mapboxgl from "mapbox-gl";
import "mapbox-gl/dist/mapbox-gl.css";
import { addArcGISFeatureLayer } from "../utils/mapLayers";

// ArcGIS Service URLs
const STATE_SERVICE = 'https://services5.arcgis.com/73n8CSGpSSyHr1T9/arcgis/rest/services/state_boundary/FeatureServer/0';
const DISTRICT_SERVICE = 'https://services5.arcgis.com/73n8CSGpSSyHr1T9/arcgis/rest/services/district_boundary/FeatureServer/0';

// State codes mapping
const STATE_CODE = {
  'Odisha': 'OD',
  'Madhya Pradesh': 'MP',
  'Tripura': 'TR',
  'Telangana': 'TG'
};

export default function Mapping() {
  const mapContainer = useRef(null);
  const mapRef = useRef(null);
  const [error, setError] = useState(null);
  const [selectedState, setSelectedState] = useState("");
  const [selectedDistrict, setSelectedDistrict] = useState("");
  const [selectedVillage, setSelectedVillage] = useState("");
  const [districts, setDistricts] = useState([]);
  
  // Registry of layer groups to control
  const layerGroups = [
    {
      id: "arcgis-features",
      label: "Water Bodies",
      sublayers: ["-fill", "-outline", "-line", "-circle", "-label"],
    },
    {
      id: "district-boundaries",
      label: "District Boundaries",
      sublayers: ["-fill", "-outline", "-line", "-circle", "-label"],
    },
    {
      id: "boundaries-layer",
      label: "State Boundaries",
      sublayers: ["-fill", "-outline", "-line", "-circle", "-label"],
    },
  ];

  // Track which groups are visible
  const [visibleGroups, setVisibleGroups] = useState(() => new Set(["district-boundaries"]));

  // Base map styles
  const styles = [
    { key: "streets", label: "Streets", url: "mapbox://styles/mapbox/streets-v12" },
    { key: "satellite", label: "Satellite", url: "mapbox://styles/mapbox/satellite-streets-v12" },
  ];
  const [selectedStyle, setSelectedStyle] = useState(styles[0]);

  // Helper function to remove layer and source
  const removeLayerAndSource = (id) => {
    const map = mapRef.current;
    if (!map) return;
    if (map.getLayer(id)) map.removeLayer(id);
    if (map.getSource(id)) map.removeSource(id);
  };

  // Function to highlight state boundary
  const showStateBoundary = async (stateName) => {
    console.log('Showing state boundary for:', stateName);
    const map = mapRef.current;
    if (!map) {
      console.error('Map not initialized');
      return;
    }

    const stateCode = STATE_CODE[stateName];
    if (!stateCode) {
      console.error('Invalid state name:', stateName);
      return;
    }

    const whereByCode = `State_Name='${stateCode}'`;
    const whereByName = `State_FSI='${stateName.replace(/'/g, "''")}'`;
    const urlByCode = `${STATE_SERVICE}/query?where=${encodeURIComponent(whereByCode)}&outFields=*&f=geojson`;
    const urlByName = `${STATE_SERVICE}/query?where=${encodeURIComponent(whereByName)}&outFields=*&f=geojson`;

    try {
      let response = await fetch(urlByCode);
      let data = await response.json();
      
      if (!data || !data.features || data.features.length === 0) {
        response = await fetch(urlByName);
        data = await response.json();
      }

      if (!data || !data.features || data.features.length === 0) {
        throw new Error('No state features found');
      }

      removeLayerAndSource('state-boundary-highlight');
      map.addSource('state-boundary-highlight', { type: 'geojson', data });
      map.addLayer({
        id: 'state-boundary-highlight',
        type: 'line',
        source: 'state-boundary-highlight',
        paint: {
          'line-color': '#0000ff',
          'line-width': 3
        }
      });

      // Calculate bounds safely
      let bounds;
      try {
        const coordinates = data.features[0].geometry.coordinates;
        if (coordinates && coordinates.length > 0 && coordinates[0].length > 0) {
          bounds = coordinates[0].reduce((acc, coord) => {
            if (Array.isArray(coord) && coord.length === 2 && 
                !isNaN(coord[0]) && !isNaN(coord[1])) {
              return [
                [Math.min(acc[0][0], coord[0]), Math.min(acc[0][1], coord[1])],
                [Math.max(acc[1][0], coord[0]), Math.max(acc[1][1], coord[1])]
              ];
            }
            return acc;
          }, [[180, 90], [-180, -90]]);
        }
      } catch (e) {
        console.error('Error calculating bounds:', e);
      }

      // Only fit bounds if we have valid coordinates
      if (bounds && bounds[0][0] !== 180 && bounds[0][1] !== 90) {
        map.fitBounds(bounds, { padding: 50, duration: 1000 });
      }
    } catch (error) {
      console.error('Error highlighting state:', error);
    }
  };

  // Function to highlight district boundary
  const showDistrictBoundary = async (stateName, districtName) => {
    console.log('Showing district boundary for:', districtName, 'in state:', stateName);
    const map = mapRef.current;
    if (!map) {
      console.error('Map not initialized');
      return;
    }

    const stateCode = STATE_CODE[stateName];
    if (!stateCode) {
      console.error('Invalid state name:', stateName);
      return;
    }

    let where = `state='${stateCode}'`;
    if (districtName) where += ` AND district='${districtName}'`;

    try {
      const response = await fetch(`${DISTRICT_SERVICE}/query?where=${encodeURIComponent(where)}&outFields=*&f=geojson`);
      const data = await response.json();

      removeLayerAndSource('district-boundary-highlight');
      map.addSource('district-boundary-highlight', { type: 'geojson', data });
      map.addLayer({
        id: 'district-boundary-highlight',
        type: 'line',
        source: 'district-boundary-highlight',
        paint: {
          'line-color': '#ffa500',
          'line-width': 2
        }
      });

      if (districtName && data.features && data.features.length > 0) {
        // Calculate bounds safely
        try {
          const coordinates = data.features[0].geometry.coordinates;
          if (coordinates && coordinates.length > 0 && coordinates[0].length > 0) {
            const bounds = coordinates[0].reduce((acc, coord) => {
              if (Array.isArray(coord) && coord.length === 2 && 
                  !isNaN(coord[0]) && !isNaN(coord[1])) {
                return [
                  [Math.min(acc[0][0], coord[0]), Math.min(acc[0][1], coord[1])],
                  [Math.max(acc[1][0], coord[0]), Math.max(acc[1][1], coord[1])]
                ];
              }
              return acc;
            }, [[180, 90], [-180, -90]]);

            if (bounds && bounds[0][0] !== 180 && bounds[0][1] !== 90) {
              map.fitBounds(bounds, { padding: 50, duration: 1000 });
            }
          }
        } catch (e) {
          console.error('Error calculating district bounds:', e);
        }
      }
    } catch (error) {
      console.error('Error highlighting district:', error);
    }
  };

  // Helper to apply current visibility to map layers
  const applyVisibility = () => {
    const map = mapRef.current;
    if (!map) return;
    layerGroups.forEach((group) => {
      const isVisible = visibleGroups.has(group.id);
      // Toggle potential sublayers (if they exist)
      group.sublayers.forEach((suffix) => {
        const layerId = `${group.id}${suffix}`;
        if (map.getLayer(layerId)) {
          map.setLayoutProperty(
            layerId,
            "visibility",
            isVisible ? "visible" : "none"
          );
        }
      });
      // Also toggle a base layer with the same id (e.g., raster tiles), if present
      if (map.getLayer(group.id)) {
        map.setLayoutProperty(
          group.id,
          "visibility",
          isVisible ? "visible" : "none"
        );
      }
    });
  };

  // Initialize map
  useEffect(() => {
    const token = import.meta.env.VITE_MAPBOX_TOKEN;
    if (!token) {
      setError(
        "Missing VITE_MAPBOX_TOKEN. Create a .env file (see .env.example) with your Mapbox access token."
      );
      return;
    }

    mapboxgl.accessToken = token;

    let map;
    try {
      // Clear the container first
      if (mapContainer.current) {
        mapContainer.current.innerHTML = '';
      }

      map = new mapboxgl.Map({
        container: mapContainer.current,
        style: selectedStyle.url,
        center: [78.9629, 22.5937], // Center of India
        zoom: 4, // Zoom level to show all of India
        attributionControl: true,
        minZoom: 3, // Prevent zooming out too far
      });
      mapRef.current = map;

      map.on('error', (e) => {
        console.error('Mapbox GL Error:', e);
        setError('Error loading map: ' + e.error.message);
      });

      map.addControl(new mapboxgl.NavigationControl({ showCompass: false }), "top-right");

      map.on("load", async () => {
        // Ensure proper sizing when the container becomes full-bleed
        map.resize();
        try {
          // Load District Boundaries layer
          await addArcGISFeatureLayer(map, {
            id: "district-boundaries",
            featureServerUrl: DISTRICT_SERVICE,
            labelField: "district",
          });
          
          // Set district boundaries style
          if (map.getLayer("district-boundaries-fill")) {
            map.setPaintProperty("district-boundaries-fill", "fill-opacity", 0);
            map.setPaintProperty("district-boundaries-fill", "fill-outline-color", "#79BAEC");
            map.setPaintProperty("district-boundaries-fill", "fill-outline-width", 1.5);
            // Move to top so outline is clearly visible
            try { map.moveLayer("district-boundaries-fill"); } catch (_) {}
          }

          // Load State Boundaries layer
          await addArcGISFeatureLayer(map, {
            id: "boundaries-layer",
            featureServerUrl: STATE_SERVICE,
            labelField: "State_FSI",
          });
          
          if (map.getLayer("boundaries-layer-fill")) {
            map.setPaintProperty("boundaries-layer-fill", "fill-opacity", 0);
            map.setPaintProperty("boundaries-layer-fill", "fill-outline-color", "#000000");
            try { map.moveLayer("boundaries-layer-fill"); } catch (_) {}
          }

          applyVisibility();
        } catch (e) {
          console.error(e);
          setError("Failed to load map layers");
        }
      });
    } catch (err) {
      console.error('Map initialization error:', err);
      setError('Failed to initialize map: ' + err.message);
      return;
    }

    // Keep map sized to container changes
    const ro = new ResizeObserver(() => {
      if (mapRef.current) mapRef.current.resize();
    });
    if (mapContainer.current) ro.observe(mapContainer.current);

    return () => {
      ro.disconnect();
      if (mapRef.current) {
        try {
          mapRef.current.remove();
          mapRef.current = null;
        } catch (err) {
          console.error('Error during map cleanup:', err);
        }
      }
    };
  }, []);

  // Handle map style changes
  useEffect(() => {
    const map = mapRef.current;
    if (!map) return;

    const handleStyleLoad = async () => {
      map.resize();

      try {
        // Re-add District Boundaries layer
        await addArcGISFeatureLayer(map, {
          id: "district-boundaries",
          featureServerUrl: DISTRICT_SERVICE,
          labelField: "district",
        });
        
        // Set district boundaries style
        if (map.getLayer("district-boundaries-fill")) {
          map.setPaintProperty("district-boundaries-fill", "fill-opacity", 0);
          map.setPaintProperty("district-boundaries-fill", "fill-outline-color", "#79BAEC");
          map.setPaintProperty("district-boundaries-fill", "fill-outline-width", 1.5);
          try { map.moveLayer("district-boundaries-fill"); } catch (_) {}
        }

        // Re-add State Boundaries layer
        await addArcGISFeatureLayer(map, {
          id: "boundaries-layer",
          featureServerUrl: STATE_SERVICE,
          labelField: "State_FSI",
        });
        
        if (map.getLayer("boundaries-layer-fill")) {
          map.setPaintProperty("boundaries-layer-fill", "fill-opacity", 0);
          map.setPaintProperty("boundaries-layer-fill", "fill-outline-color", "#000000");
          try { map.moveLayer("boundaries-layer-fill"); } catch (_) {}
        }

        applyVisibility();
      } catch (e) {
        console.error('Error reloading layers:', e);
      }
    };

    map.once('style.load', handleStyleLoad);
    map.setStyle(selectedStyle.url);

    return () => {
      map.off('style.load', handleStyleLoad);
    };
  }, [selectedStyle]);

  // Re-apply visibility when toggles change
  useEffect(() => {
    applyVisibility();
  }, [visibleGroups]);

  // Fetch districts when state is selected
  useEffect(() => {
    if (!selectedState) {
      setDistricts([]);
      removeLayerAndSource('state-boundary-highlight');
      removeLayerAndSource('district-boundary-highlight');
      return;
    }

    console.log('Fetching districts for state:', selectedState);
    const stateCode = STATE_CODE[selectedState];
    const where = `state='${stateCode}'`;
    const url = `${DISTRICT_SERVICE}/query?where=${encodeURIComponent(where)}&outFields=district&returnDistinctValues=true&returnGeometry=false&f=json`;

    fetch(url)
      .then(res => res.json())
      .then(json => {
        console.log('Districts response:', json);
        const districtList = (json.features || [])
          .map(f => (f.attributes && (f.attributes.district || f.attributes.District)))
          .filter(Boolean)
          .sort((a, b) => a.localeCompare(b));
        console.log('Processed district list:', districtList);
        setDistricts(districtList);
      })
      .catch(err => {
        console.error('Failed to load districts:', err);
        setDistricts([]);
      });

    // Highlight state boundary when state is selected
    showStateBoundary(selectedState);
  }, [selectedState]);

  // Handle district selection changes
  useEffect(() => {
    if (!selectedState || !selectedDistrict) {
      removeLayerAndSource('district-boundary-highlight');
      return;
    }

    console.log('Highlighting district:', selectedDistrict, 'in state:', selectedState);
    showDistrictBoundary(selectedState, selectedDistrict);
  }, [selectedState, selectedDistrict]);

  return (
    <div className="relative h-screen w-full overflow-hidden flex flex-col">
      {/* Top Navigation Bar */}
      <div className="w-full bg-white shadow-md z-20">
        <div className="container mx-auto px-4 py-3">
          {/* Navigation Tabs */}
          <div className="flex items-center gap-6">
            {/* Location Selection */}
            <div className="flex-1">
              <div className="flex items-center gap-4">
                <select
                  className="text-sm px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white shadow-sm min-w-[180px]"
                  value={selectedState}
                  onChange={(e) => {
                    const newState = e.target.value;
                    setSelectedState(newState);
                    setSelectedDistrict("");
                    setSelectedVillage("");
                    removeLayerAndSource('district-boundary-highlight');
                    if (!newState) {
                      removeLayerAndSource('state-boundary-highlight');
                    }
                  }}
                >
                  <option value="">Select State</option>
                  {Object.keys(STATE_CODE).map(state => (
                    <option key={state} value={state}>{state}</option>
                  ))}
                </select>

                <select
                  className="text-sm px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white shadow-sm min-w-[180px]"
                  value={selectedDistrict}
                  onChange={(e) => {
                    const newDistrict = e.target.value;
                    setSelectedDistrict(newDistrict);
                    setSelectedVillage("");
                  }}
                  disabled={!selectedState}
                >
                  <option value="">Select District</option>
                  {districts.map(district => (
                    <option key={district} value={district}>{district}</option>
                  ))}
                </select>

                <select
                  className="text-sm px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white shadow-sm min-w-[180px]"
                  value={selectedVillage}
                  onChange={(e) => setSelectedVillage(e.target.value)}
                  disabled={!selectedDistrict}
                >
                  <option value="">Select Village</option>
                  {/* Village options will be added when you provide the logic */}
                </select>
              </div>
            </div>

            {/* Base Map Style Selector */}
            <div className="flex items-center">
              <select
                className="text-sm px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 bg-white shadow-sm"
                value={selectedStyle.key}
                onChange={(e) => {
                  const next = styles.find((s) => s.key === e.target.value);
                  if (next) setSelectedStyle(next);
                }}
              >
                {styles.map((s) => (
                  <option key={s.key} value={s.key}>{s.label}</option>
                ))}
              </select>
            </div>
          </div>

          {/* Layers Section - Only visible when state is selected */}
          {selectedState && (
            <div className="mt-3 pt-3 border-t border-gray-200">
              <div className="flex items-center gap-6">
                <span className="text-sm font-medium text-gray-600">Layers:</span>
                {layerGroups.map((g) => (
                  <label
                    key={g.id}
                    className="flex items-center gap-2 text-sm text-gray-800 select-none cursor-pointer"
                  >
                    <input
                      type="checkbox"
                      className="h-4 w-4 rounded-sm border-gray-300 text-blue-600 focus:ring-blue-500"
                      checked={visibleGroups.has(g.id)}
                      onChange={(e) =>
                        setVisibleGroups((prev) => {
                          const next = new Set(prev);
                          if (e.target.checked) next.add(g.id);
                          else next.delete(g.id);
                          return next;
                        })
                      }
                    />
                    <span>{g.label}</span>
                  </label>
                ))}
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Error display */}
      {error && (
        <div className="absolute top-20 left-4 z-30">
          <div className="rounded-md border border-amber-300 bg-amber-50/95 text-amber-900 p-2 text-xs max-w-sm">
            {error}
          </div>
        </div>
      )}

      {/* Map Container */}
      <div 
        ref={mapContainer} 
        className="flex-1 w-full bg-gray-100"
        style={{ minHeight: 'calc(100vh - 100px)' }} 
      />
    </div>
  );
}